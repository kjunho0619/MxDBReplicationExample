// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package databasereplication.actions;

import com.mendix.core.CoreException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import com.mendix.webui.FeedbackHelper;
import databasereplication.implementation.ObjectBaseDBSettings;
import databasereplication.proxies.Database;
import databasereplication.proxies.TableMapping;

/**
 * Use the ImportCall to start a table import. Before starting the mapping the action will analyse and translate the constraints from the importcall 
 * 
 * Parameter InputOne and InputTwo are the instances of the two objects you can configure to use to set an association or to apply constraints. If you have specified to set an association to any of those objects or apply a constraint this will automatically by applied in this Java action. 
 * 
 * The parameter ApplyEntityAccess specifies if the import should run withor without all the security constraints of the user who triggers the import.
 * When you change this parameter to false, it will run without any security limitations (i.e. as MxAdministrator)
 * 
 * 
 * The result of this action is always 'true', if the import fails at any point it will return in an exception. 
 * 
 * The rollback behaviour is determined by your microflow and the transaction parameters in the TableMapping.
 */
public class ImportByImportCall extends CustomJavaAction<java.lang.Boolean>
{
	/** @deprecated use CallConfig.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __CallConfig;
	private final databasereplication.proxies.ImportCall CallConfig;
	private final IMendixObject InputOne;
	private final IMendixObject InputTwo;
	private final java.lang.Boolean ApplyEntityAcces;

	public ImportByImportCall(
		IContext context,
		IMendixObject _callConfig,
		IMendixObject _inputOne,
		IMendixObject _inputTwo,
		java.lang.Boolean _applyEntityAcces
	)
	{
		super(context);
		this.__CallConfig = _callConfig;
		this.CallConfig = _callConfig == null ? null : databasereplication.proxies.ImportCall.initialize(getContext(), _callConfig);
		this.InputOne = _inputOne;
		this.InputTwo = _inputTwo;
		this.ApplyEntityAcces = _applyEntityAcces;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = this.getContext();
		TableMapping mapping = this.CallConfig.getImportCall_TableMapping();
		if(mapping == null)
		{
			throw new CoreException("There is no mapping defined in the importcall object. Importing can not be done");
		}
		Database CurDatabase = mapping.getTableMapping_Database(context);

		ObjectBaseDBSettings dbSettings = new ObjectBaseDBSettings( context, CurDatabase.getMendixObject() );
		ImportByMapping.importFromDatabaseWithImportCall(context, mapping, dbSettings, this, this.CallConfig, this.InputOne, this.InputTwo, this.ApplyEntityAcces);

		FeedbackHelper.addRefreshClass(this.getContext(), mapping.getTableMapping_MxObjectType().getCompleteName());
		
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ImportByImportCall";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
